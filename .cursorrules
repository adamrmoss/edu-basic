# ⚠️ CRITICAL RULES - VERIFY BEFORE EVERY RESPONSE ⚠️

## FORBIDDEN ACTIONS
- ❌ NEVER run shell commands or terminal commands (user has sole discretion)
- ❌ NEVER make code changes without explicit user request
- ❌ NEVER assume work is complete without verification
- ❌ NEVER create generic folders like `controllers/`, `views/`, `services/`
- ❌ NEVER inline comments (always on their own line)
- ❌ NEVER include HTML/SCSS directly in TypeScript components (use separate files)

## REQUIRED ACTIONS
- ✅ ALWAYS answer questions directly BEFORE taking action
- ✅ ALWAYS verify changes by reading the actual file output
- ✅ ALWAYS use standalone Angular components with separate template/stylesheet files
- ✅ ALWAYS use explicit 'this.' in C# code for instance members
- ✅ ALWAYS use braces { } for all control structures in C#, even single-line blocks
- ✅ ALWAYS save executable scripts (SQL, T-SQL, etc.) to appropriately named files

---

# Problem-Solving Strategy

When solving problems, follow this workflow:

1. **Plan First**: Understand the problem, read examples, identify patterns
2. **Test Manually**: Use search_replace on ONE example to verify the approach works
3. **Apply Systematically**: Use grep to find patterns, then fix iteratively with search_replace
4. **Only Script When Necessary**: Use scripts only for complex logic that cannot be done with search_replace
5. **Verify Work**: Always read the actual file output to confirm changes worked
6. **Never Be Overconfident**: Don't claim completion without verification

**Avoid running scripts as a first solution** - prefer manual search_replace operations.

---

# Communication & Workflow

- When user says they already fixed something, acknowledge it and move on (don't offer to fix it again)
- Add comments only for documenting the codebase, not for conveying info to the developer (use chat for that)
- Save all standalone executable code (SQL scripts, etc.) to files instead of only displaying in chat

---

# Documentation

## Documentation Location

**Documentation is co-located with code** - README.md files are placed in the same directories as the code they describe.

## Generated Artifacts in docs/

- **`.html` and `.pdf` files in `docs/` are generated artifacts** - they are produced from source (e.g. markdown) and must not be edited directly
- Edit the source files instead; regenerate the HTML/PDF when needed
- Do not propose or make changes to `docs/*.html` or `docs/*.pdf`

## Documentation Structure

- **`docs/architecture.md`** - High-level system architecture overview
- **`src/app/README.md`** - Application components (Console, Code Editor, Output, Files)
- **`src/app/interpreter/README.md`** - Interpreter services (ParserService, TokenizerService, ExpressionParserService, GraphicsService, AudioService, InterpreterService)
- **`src/app/console/README.md`** - ConsoleService documentation
- **`src/lang/README.md`** - Language core (value system, ExecutionContext, Program, RuntimeExecution, Graphics, Audio)
- **`src/lang/expressions/README.md`** - Expression system (all expression types, parsing, evaluation)
- **`src/lang/statements/README.md`** - Statement system (all statement types, execution)

## Documentation Usage

**BEFORE making changes or answering questions:**
1. **Check for README.md** in the directory you're working in
2. **Read relevant documentation** to understand the system architecture
3. **Consult documentation** when:
   - Understanding how a component/service works
   - Adding new features
   - Modifying existing functionality
   - Debugging issues
   - Explaining system behavior

**When working in a directory:**
- Always check if a `README.md` exists in that directory
- Read the README to understand the code structure and design decisions
- Use documentation to understand dependencies and integration points

**Documentation covers:**
- Class/component purposes and responsibilities
- Key methods and properties
- Data flow and integration points
- Design decisions and patterns
- Examples and usage patterns

---

# Technology-Specific Rules

## Angular
- **ALWAYS use standalone components** - Every `@Component` decorator MUST include `standalone: true`
- Use separate files for templates (.html) and stylesheets (.scss) - NEVER include HTML/SCSS directly in TypeScript components
- Prefer TypeScript over JavaScript
- Prefer SCSS over CSS
- **ALWAYS use IconComponent from ng-luna** - NEVER create custom SVG icons or invent your own icon rendering
  - Use `<luna-icon>` component with the appropriate icon from ng-luna (e.g., `Folder`, `File`, `Edit`, `Trash`)
  - For drag images or other DOM manipulation, clone the actual DOM elements that use IconComponent, never create facsimiles
- **SCSS Property Ordering**: ALL CSS/SCSS properties MUST be alphabetized within each selector block
  - Properties should be sorted alphabetically by property name (e.g., `align-items`, `background-color`, `border`, `color`, `display`, `font-size`, etc.)
  - This applies to all selector blocks, including nested selectors, pseudo-classes (`:hover`, `:active`, etc.), and pseudo-elements (`::placeholder`, etc.)
  - Example: `{ align-items: center; background-color: $navy; display: flex; }` ✅
  - Example: `{ display: flex; align-items: center; background-color: $navy; }` ❌

## C# Code Style
- Use explicit 'this.' to reference instance members (methods and properties)
- Use braces { } for all control structures, even single-line blocks
- Add line breaks between logical groups of code for readability
- Keep each logical operation visually separate

## TypeScript/JavaScript Code Style
- Prefer switch statements over else-if chains when checking the same variable
- Use braces { } for all control structures, even single-line blocks
- ALL decorators must be on their own line (never on the same line as the property/method they decorate)
- ALL class properties and methods must have explicit access modifiers (public, private, or protected)
- **Property Syntax**: Use property getters and setters instead of getter/setter methods for better readability
  - Related properties should be adjacent: getter immediately followed by its setter
  - Example: `public get value(): T { ... }` followed by `public set value(v: T) { ... }`
  - This applies to services, components, and all TypeScript classes
- **File Endings**: Files must end with exactly one newline character after the last content line
  - The last line of content should be followed by a single newline, then EOF
  - Do NOT include two blank lines at the end of files
- **Error Handling**: Prefer returning null over throwing exceptions for recoverable errors
  - Parsing methods (e.g., `parseLine`, `parseExpression`) should return `T | null` instead of throwing
  - Use null returns to indicate failure states that callers can handle gracefully
  - Avoid try-catch blocks for expected failure cases - check for null instead
  - Exceptions should be reserved for truly exceptional/unexpected errors
  - Example: `parseLine()` returns `ParsedLine | null` on parse failure, not a ParsedLine with `hasError: true`

## Architecture
- Divide solutions by layers into projects
- Subdivide projects semantically in domain space
- Organize by domain concepts, NOT by technical layers

## Module Organization & Barrel Files
- **ALWAYS use barrel files (index.ts) for directories with multiple exports**
- **Barrel files MUST be created for:**
  - Any directory containing 3+ related TypeScript files that export classes/types/interfaces
  - Subdirectories that group related functionality (e.g., `statements/array/`, `statements/control-flow/`)
  - Main directories that contain subdirectories (e.g., `statements/`, `expressions/`)
- **Barrel file structure:**
  - Use `export * from './filename'` for each file in the directory
  - Do NOT export non-public utilities or internal helpers from barrel files
  - Main barrel files should re-export from subdirectory barrels when appropriate
- **Import rules:**
  - **ALWAYS import from barrel files** (e.g., `from './statements/array'`) instead of individual files (e.g., `from './statements/array/pop-statement'`)
  - Use barrel files to simplify imports and reduce path length
  - Group related imports from the same barrel on a single line when appropriate
- **Examples:**
  - ✅ `import { PopStatement, PushStatement } from '../../lang/statements/array'`
  - ❌ `import { PopStatement } from '../../lang/statements/array/pop-statement'`
  - ✅ `import { IfStatement, WhileStatement } from '../../lang/statements/control-flow'`
  - ❌ `import { IfStatement } from '../../lang/statements/control-flow/if-statement'`

## EduBASIC Language Terminology
- NEVER use the term "function" for computational operations (e.g., SIN, COS, PRINT)
- In EduBASIC, "function" is ONLY used for set-theoretic mathematical functions
- Use "operator", "statement", "command", or "keyword" for computational operations
- Examples: "SIN operator", "PRINT statement", "IF statement" (NOT "SIN function", "PRINT function")
